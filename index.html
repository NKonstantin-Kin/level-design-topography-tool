<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <title>Топографический редактор PRO</title>
  <style>
    /* Все стили остаются точно такими же, как в предыдущей версии */
    body { margin: 0; font-family: Arial; background: #f5f5f5; overflow: hidden; }
    #app { display: flex; height: 100vh; }
    #toolbar { width: 200px; background: #2c3e50; padding: 15px; color: white; box-shadow: 0 0 10px rgba(0,0,0,0.3); overflow-y: auto; }
    /* ... (остальные стили без изменений) ... */
    .transform-handle {
      position: absolute;
      width: 8px;
      height: 8px;
      background: #1abc9c;
      border: 2px solid white;
      border-radius: 50%;
      pointer-events: all;
      cursor: pointer;
      z-index: 20;
      transform: translate(-50%, -50%);
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Весь HTML остаётся без изменений -->
    <div id="toolbar">...</div>
    <div id="canvas-container">
      <div class="tabs" id="sheet-tabs"></div>
      <canvas id="sheet"></canvas>
      <div id="text-input" contenteditable="true"></div>
      <div id="transform-handles"></div>
    </div>
  </div>
  <div id="rename-dialog">...</div>
  <script>
  // ========== КОНФИГУРАЦИЯ И ИНИЦИАЛИЗАЦИЯ ==========
  const CONFIG = {
    CANVAS_WIDTH: 2500,
    CANVAS_HEIGHT: 1500,
    GRID_COLOR: '#e0e0e0',
    HANDLE_SIZE: 8,
    HANDLE_COLOR: '#1abc9c',
    SELECTION_COLOR: '#FF0000'
  };

  const canvas = document.getElementById('sheet');
  const ctx = canvas.getContext('2d');
  const textInput = document.getElementById('text-input');
  const transformHandles = document.getElementById('transform-handles');
  canvas.width = CONFIG.CANVAS_WIDTH;
  canvas.height = CONFIG.CANVAS_HEIGHT;

  let state = {
    sheets: [],
    currentSheet: 0,
    currentTool: 'select',
    color: '#000000',
    selectedElement: null,
    undoStack: [],
    redoStack: [],
    grid: { enabled: true, snap: true, step: 20, color: CONFIG.GRID_COLOR },
    elements: [],
    renamingSheet: null,
    textInputActive: false,
    isDrawing: false,
    startX: 0,
    startY: 0,
    isDragging: false,
    dragStartX: 0,
    dragStartY: 0,
    transformHandle: null,
    originalElement: null
  };

  // ========== ОСНОВНЫЕ ФУНКЦИИ ==========
  function drawGrid() {
    if (!state.grid.enabled) return;
    ctx.strokeStyle = state.grid.color;
    ctx.lineWidth = 1;
    for (let x = 0; x <= canvas.width; x += state.grid.step) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
    for (let y = 0; y <= canvas.height; y += state.grid.step) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }
  }

  function renderTransformHandles() {
    transformHandles.innerHTML = '';
    if (state.selectedElement === null) return;

    const element = state.elements[state.selectedElement];
    if (!element) return;

    const canvasRect = canvas.getBoundingClientRect();
    const containerRect = document.getElementById('canvas-container').getBoundingClientRect();
    const scrollLeft = document.getElementById('canvas-container').scrollLeft;
    const scrollTop = document.getElementById('canvas-container').scrollTop;

    const offsetX = canvasRect.left - containerRect.left + scrollLeft;
    const offsetY = canvasRect.top - containerRect.top + scrollTop;

    if (element.type === 'rect') {
      const handles = [
        { x: element.x1, y: element.y1, type: 'nw' },
        { x: (element.x1 + element.x2)/2, y: element.y1, type: 'n' },
        { x: element.x2, y: element.y1, type: 'ne' },
        { x: element.x1, y: (element.y1 + element.y2)/2, type: 'w' },
        { x: element.x2, y: (element.y1 + element.y2)/2, type: 'e' },
        { x: element.x1, y: element.y2, type: 'sw' },
        { x: (element.x1 + element.x2)/2, y: element.y2, type: 's' },
        { x: element.x2, y: element.y2, type: 'se' }
      ];

      handles.forEach(handle => {
        const handleEl = document.createElement('div');
        handleEl.className = 'transform-handle';
        handleEl.style.left = `${handle.x + offsetX}px`;
        handleEl.style.top = `${handle.y + offsetY}px`;
        handleEl.dataset.type = handle.type;
        transformHandles.appendChild(handleEl);
      });
    }
  }

  function renderCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGrid();
    renderElements();
    renderTransformHandles();
  }

  // ========== РАБОТА С ЛОКАЛЬНЫМ ХРАНИЛИЩЕМ ==========
  function saveToLocalStorage() {
    state.sheets[state.currentSheet].elements = state.elements;
    localStorage.setItem('levelDesigner', JSON.stringify(state));
  }

  function loadFromLocalStorage() {
    const saved = localStorage.getItem('levelDesigner');
    if (saved) {
      state = JSON.parse(saved);
      if (state.sheets.length === 0) {
        createSheet();
      } else {
        state.elements = state.sheets[state.currentSheet].elements;
      }
    } else {
      createSheet();
    }
    renderTabs();
    renderCanvas();
  }

  // ========== ЗАПУСК ==========
  document.addEventListener('DOMContentLoaded', () => {
    loadFromLocalStorage();
    setActiveTool('select');
    
    // Инициализация обработчиков событий
    document.getElementById('new-sheet').addEventListener('click', createSheet);
    document.getElementById('tool-select').addEventListener('click', () => setActiveTool('select'));
    // ... (остальные обработчики без изменений)
  });
</script>
</body>
</html>
