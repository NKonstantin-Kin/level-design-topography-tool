<!DOCTYPE html>
<html>
<head>
    <title>Topography Editor</title>
    <style>
        body { margin: 0; font-family: Arial, sans-serif; }
        .toolbar { padding: 10px; background: #f0f0f0; border-bottom: 1px solid #ddd; }
        .tabs { margin-bottom: 10px; }
        button { padding: 6px 12px; margin-right: 5px; cursor: pointer; }
        canvas { border: 1px solid #ccc; margin: 20px; }
        .grid-settings { margin-top: 10px; padding: 10px; background: #fff; border: 1px solid #ddd; }
    </style>
</head>
<body>
    <div class="toolbar">
        <div class="tabs">
            <button onclick="switchTab(0)">Layer 1</button>
            <button onclick="switchTab(1)">Layer 2</button>
            <button onclick="addTab()">+</button>
        </div>
        
        <button id="lineTool">Line</button>
        <button id="rectTool">Rectangle</button>
        <button id="circleTool">Circle</button>
        <button id="textTool">Text</button>
        
        <div class="grid-settings">
            <label>
                <input type="checkbox" id="gridToggle" checked> Show Grid
            </label>
            <input type="number" id="gridSize" value="20" min="5" max="100">
        </div>
        
        <div>
            <button onclick="deleteSelected()">Delete (Del)</button>
            <button onclick="groupSelected()">Group (Ctrl+G)</button>
            <button onclick="ungroupSelected()">Ungroup (Ctrl+Shift+G)</button>
        </div>
    </div>
    
    <canvas id="canvas"></canvas>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // 1. DOM Elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let activeTool = 'select';
        let isDrawing = false;
        let currentElement = null;

        // 2. Config
        const config = {
            gridSize: 20,
            snapToGrid: true,
            canvasWidth: 2000,
            canvasHeight: 2000
        };

        // 3. State
        let state = {
            elements: [],
            selectedElements: new Set(),
            canvasOffset: { x: 0, y: 0 },
            undoStack: [],
            redoStack: [],
            currentTab: 0,
            tabs: [{
                name: "Layer 1",
                elements: []
            }]
        };

        // 4. Functions
        // Экспорт функций в глобальную область
        window.deleteSelected = () => {
            state.tabs[state.currentTab].elements = state.tabs[state.currentTab].elements
                .filter((_, i) => !state.selectedElements.has(i));
            state.selectedElements.clear();
            draw();
        };

        window.switchTab = (tabIndex) => {
            state.currentTab = tabIndex;
            draw();
        };

        window.addTab = () => {
            state.tabs.push({
                name: `Layer ${state.tabs.length + 1}`,
                elements: []
            });
        };

        window.groupSelected = () => {
            if(state.selectedElements.size > 1) {
                const group = {
                    type: 'group',
                    children: Array.from(state.selectedElements),
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
                state.tabs[state.currentTab].elements.push(group);
                state.selectedElements.clear();
                draw();
            }
        };

        window.ungroupSelected = () => {
            // Заглушка для реализации
            alert('Ungroup functionality coming soon!');
        };

        const tools = {
            line: (x, y) => {
                return {
                    type: 'line',
                    x1: x,
                    y1: y,
                    x2: x,
                    y2: y,
                    color: '#ff0000'
                };
            },
            rect: (x, y) => {
                return {
                    type: 'rect',
                    x: x,
                    y: y,
                    width: 0,
                    height: 0,
                    color: '#00ff00'
                };
            },
            circle: (x, y) => {
                return {
                    type: 'circle',
                    x: x,
                    y: y,
                    radius: 0,
                    color: '#0000ff'
                };
            }
        };

        function draw() {
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.translate(state.canvasOffset.x, state.canvasOffset.y);

            // Draw grid
            if(document.getElementById('gridToggle').checked) {
                const gridSize = parseInt(document.getElementById('gridSize').value);
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 0.5;
                for(let x = 0; x < canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                for(let y = 0; y < canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }

            // Draw elements
            state.tabs[state.currentTab].elements.forEach((element, index) => {
                ctx.fillStyle = element.color || '#000';
                ctx.strokeStyle = element.color || '#000';
                ctx.lineWidth = 2;

                if(state.selectedElements.has(index)) {
                    ctx.strokeStyle = '#ff0000';
                }

                switch(element.type) {
                    case 'line':
                        ctx.beginPath();
                        ctx.moveTo(element.x1, element.y1);
                        ctx.lineTo(element.x2, element.y2);
                        ctx.stroke();
                        break;
                    case 'rect':
                        ctx.strokeRect(element.x, element.y, element.width, element.height);
                        break;
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(element.x, element.y, element.radius, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                }
            });
            ctx.restore();
        }

        // 5. Event Handlers
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left - state.canvasOffset.x;
            const y = e.clientY - rect.top - state.canvasOffset.y;

            if(activeTool !== 'select') {
                isDrawing = true;
                currentElement = tools[activeTool](x, y);
                return;
            }

            // Selection logic
            state.selectedElements.clear();
            state.tabs[state.currentTab].elements.forEach((element, index) => {
                if(checkCollision(element, x, y)) {
                    state.selectedElements.add(index);
                }
            });
            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            if(!isDrawing || !currentElement) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left - state.canvasOffset.x;
            const y = e.clientY - rect.top - state.canvasOffset.y;

            switch(currentElement.type) {
                case 'line':
                    currentElement.x2 = x;
                    currentElement.y2 = y;
                    break;
                case 'rect':
                    currentElement.width = x - currentElement.x;
                    currentElement.height = y - currentElement.y;
                    break;
                case 'circle':
                    currentElement.radius = Math.hypot(
                        x - currentElement.x,
                        y - currentElement.y
                    );
                    break;
            }
            drawTempElement();
        });

        canvas.addEventListener('mouseup', () => {
            if(isDrawing && currentElement) {
                state.tabs[state.currentTab].elements.push(currentElement);
                currentElement = null;
                isDrawing = false;
                draw();
            }
        });

        function drawTempElement() {
            ctx.save();
            ctx.translate(state.canvasOffset.x, state.canvasOffset.y);
            ctx.beginPath();
            ctx.strokeStyle = currentElement.color;
            
            switch(currentElement.type) {
                case 'line':
                    ctx.moveTo(currentElement.x1, currentElement.y1);
                    ctx.lineTo(currentElement.x2, currentElement.y2);
                    break;
                case 'rect':
                    ctx.strokeRect(
                        currentElement.x,
                        currentElement.y,
                        currentElement.width,
                        currentElement.height
                    );
                    break;
                case 'circle':
                    ctx.arc(
                        currentElement.x,
                        currentElement.y,
                        currentElement.radius,
                        0,
                        Math.PI * 2
                    );
                    break;
            }
            ctx.stroke();
            ctx.restore();
        }

        function checkCollision(element, x, y) {
            switch(element.type) {
                case 'rect':
                    return x > element.x && 
                           x < element.x + element.width &&
                           y > element.y && 
                           y < element.y + element.height;
                case 'circle':
                    return Math.hypot(x - element.x, y - element.y) < element.radius;
                case 'line':
                    // Упрощенная проверка для линии
                    const dx = element.x2 - element.x1;
                    const dy = element.y2 - element.y1;
                    const t = ((x - element.x1) * dx + (y - element.y1) * dy) / (dx*dx + dy*dy);
                    return t >= 0 && t <= 1;
            }
            return false;
        }

        // Инициализация инструментов
        document.getElementById('lineTool').addEventListener('click', () => activeTool = 'line');
        document.getElementById('rectTool').addEventListener('click', () => activeTool = 'rect');
        document.getElementById('circleTool').addEventListener('click', () => activeTool = 'circle');

        // 6. Init
        function init() {
            canvas.width = config.canvasWidth;
            canvas.height = config.canvasHeight;
            draw();
        }

        init();
    });
    </script>
</body>
</html>
