<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <title>Топографический редактор PRO</title>
  <style>
    /* ... (все ваши стили остаются без изменений) ... */
    
    /* Добавляем новые стили для функционала */
    canvas.move-cursor {
      cursor: grab;
    }
    canvas.move-cursor:active {
      cursor: grabbing;
    }
    .selection-box {
      position: absolute;
      border: 2px dashed #1a73e8;
      background: rgba(26, 115, 232, 0.1);
      pointer-events: none;
      display: none;
    }
  </style>
</head>
<body>
  <!-- ... (ваш HTML остаётся без изменений до canvas-container) ... -->
  
  <div id="canvas-container">
    <div class="tabs" id="sheet-tabs"></div>
    <canvas id="sheet"></canvas>
    <div id="text-input" contenteditable="true"></div>
    <div id="selection-box" class="selection-box"></div>
  </div>

  <!-- ... (остальной HTML остаётся без изменений) ... -->

  <script>
  document.addEventListener('DOMContentLoaded', function() {
    // ========== КОНФИГУРАЦИЯ ==========
    const CONFIG = {
      INIT_WIDTH: 2500,
      INIT_HEIGHT: 1500,
      GRID_COLOR: '#e0e0e0',
      MARGIN: 200,
      MIN_CANVAS_SIZE: 500
    };

    // ========== ИНИЦИАЛИЗАЦИЯ ==========
    const canvas = document.getElementById('sheet');
    const ctx = canvas.getContext('2d');
    const textInput = document.getElementById('text-input');
    const selectionBox = document.getElementById('selection-box');
    
    // Проверка элементов
    if (!canvas || !ctx) {
      console.error('Canvas не найден или не поддерживается');
      return;
    }

    // Инициализация размеров
    canvas.width = CONFIG.INIT_WIDTH;
    canvas.height = CONFIG.INIT_HEIGHT;

    let state = {
      // ... (ваше текущее состояние) ...
      // Добавляем новые свойства:
      isMovingCanvas: false,
      canvasOffset: { x: 0, y: 0 },
      lastMousePos: { x: 0, y: 0 },
      isMovingElement: false,
      originalElementPos: null,
      isBoxSelecting: false,
      boxSelectStart: { x: 0, y: 0 }
    };

    // ========== ОСНОВНЫЕ ФУНКЦИИ ==========
    
    // 1. Автоматическое расширение холста
    function expandCanvasIfNeeded(x, y) {
      let changed = false;
      let newWidth = canvas.width;
      let newHeight = canvas.height;
      let offsetX = 0;
      let offsetY = 0;

      // Проверка границ и расширение
      if (x < CONFIG.MARGIN) {
        offsetX = CONFIG.MARGIN - x;
        newWidth += offsetX;
        changed = true;
      } 
      else if (x > canvas.width - CONFIG.MARGIN) {
        newWidth = x + CONFIG.MARGIN;
        changed = true;
      }

      if (y < CONFIG.MARGIN) {
        offsetY = CONFIG.MARGIN - y;
        newHeight += offsetY;
        changed = true;
      }
      else if (y > canvas.height - CONFIG.MARGIN) {
        newHeight = y + CONFIG.MARGIN;
        changed = true;
      }

      if (changed) {
        // Сохраняем содержимое
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = Math.max(newWidth, CONFIG.MIN_CANVAS_SIZE);
        tempCanvas.height = Math.max(newHeight, CONFIG.MIN_CANVAS_SIZE);
        
        // Копируем содержимое с учетом смещения
        tempCtx.drawImage(canvas, offsetX, offsetY);
        
        // Обновляем основной холст
        canvas.width = tempCanvas.width;
        canvas.height = tempCanvas.height;
        ctx.drawImage(tempCanvas, 0, 0);
        
        // Корректируем позиции элементов
        if (offsetX !== 0 || offsetY !== 0) {
          state.elements.forEach(el => {
            if (el.type === 'text') {
              el.x += offsetX;
              el.y += offsetY;
            } else {
              el.x1 += offsetX;
              el.y1 += offsetY;
              if (el.x2) el.x2 += offsetX;
              if (el.y2) el.y2 += offsetY;
            }
          });
        }
        
        state.canvasOffset.x += offsetX;
        state.canvasOffset.y += offsetY;
      }
    }

    // 2. Функции для работы с группами
    class Group {
      constructor(elements = []) {
        this.id = `group-${Date.now()}`;
        this.type = 'group';
        this.children = elements.map(el => el.id);
        this.updateBounds();
      }

      updateBounds() {
        const children = this.children.map(id => 
          state.elements.find(el => el.id === id)).filter(Boolean);
        
        if (children.length === 0) return;

        const xs = children.flatMap(el => [
          el.x1 || el.x,
          el.x2 || (el.x1 + (el.width || 0)) || el.x
        ]);
        const ys = children.flatMap(el => [
          el.y1 || el.y,
          el.y2 || (el.y1 + (el.height || 0)) || el.y
        ]);

        this.x = Math.min(...xs);
        this.y = Math.min(...ys);
        this.width = Math.max(...xs) - this.x;
        this.height = Math.max(...ys) - this.y;
      }
    }

    // 3. Обновленный рендеринг с учетом групп
    function renderElements() {
      ctx.save();
      ctx.translate(state.canvasOffset.x, state.canvasOffset.y);
      
      state.elements.forEach((el, index) => {
        // ... (ваш существующий код рендеринга) ...
        
        // Добавляем рендеринг выделения для групп
        if (index === state.selectedElement && el.type === 'group') {
          ctx.strokeStyle = '#1a73e8';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 3]);
          ctx.strokeRect(el.x, el.y, el.width, el.height);
          ctx.setLineDash([]);
        }
      });
      
      ctx.restore();
    }

    // 4. Обработчики событий для нового функционала
    canvas.addEventListener('mousedown', function(e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left - state.canvasOffset.x;
      const y = e.clientY - rect.top - state.canvasOffset.y;
      
      state.lastMousePos = { x: e.clientX, y: e.clientY };

      if (state.currentTool === 'select') {
        // ... (ваш существующий код) ...
        
        // Добавляем обработку перемещения холста
        if (state.selectedElement === null && !state.isResizing) {
          state.isMovingCanvas = true;
          canvas.classList.add('move-cursor');
        }
      }
    });

    canvas.addEventListener('mousemove', function(e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left - state.canvasOffset.x;
      const y = e.clientY - rect.top - state.canvasOffset.y;

      // Обработка перемещения холста
      if (state.isMovingCanvas) {
        const dx = e.clientX - state.lastMousePos.x;
        const dy = e.clientY - state.lastMousePos.y;
        
        state.canvasOffset.x += dx;
        state.canvasOffset.y += dy;
        state.lastMousePos = { x: e.clientX, y: e.clientY };
        
        renderCanvas();
        return;
      }

      // ... (остальные обработчики) ...
    });

    // 5. Обновленные горячие клавиши
    document.addEventListener('keydown', function(e) {
      // Группировка Ctrl+G
      if (e.ctrlKey && e.key === 'g' && state.selectedElement !== null) {
        e.preventDefault();
        // ... код группировки ...
      }
      
      // Разгруппировка Ctrl+Shift+G
      if (e.ctrlKey && e.shiftKey && e.key === 'g' && state.selectedElement !== null) {
        e.preventDefault();
        // ... код разгруппировки ...
      }

      // ... (остальные горячие клавиши) ...
    });

    // ========== ИНИЦИАЛИЗАЦИЯ ИНТЕРФЕЙСА ==========
    // Добавляем кнопки группировки
    const groupBtn = document.createElement('button');
    groupBtn.id = 'group-btn';
    groupBtn.className = 'tool-btn';
    groupBtn.textContent = 'Группировать (Ctrl+G)';
    groupBtn.addEventListener('click', groupElements);
    document.querySelector('.tool-section:nth-child(2)').appendChild(groupBtn);

    const ungroupBtn = document.createElement('button');
    ungroupBtn.id = 'ungroup-btn';
    ungroupBtn.className = 'tool-btn';
    ungroupBtn.textContent = 'Разгруппировать (Ctrl+Shift+G)';
    ungroupBtn.addEventListener('click', ungroupElements);
    document.querySelector('.tool-section:nth-child(2)').appendChild(ungroupBtn);

    // ========== ЗАПУСК ==========
    loadFromLocalStorage();
    setActiveTool('select');
    renderCanvas();
  });
  </script>
</body>
</html>
