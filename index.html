<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Топографический редактор с сеткой</title>
    <style>
        /* ... (прежние стили без изменений) ... */
        
        .grid-controls {
            padding: 10px;
            background: #fff;
            border-bottom: 1px solid #ddd;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .grid-controls input {
            width: 60px;
            padding: 4px;
        }
    </style>
</head>
<body>
    <div class="grid-controls">
        <span>Шаг сетки:</span>
        <input type="number" id="gridSize" value="20" min="10" max="100">
        <button id="toggleGrid">Сетка: Вкл</button>
    </div>
    <div class="toolbar">
        <!-- ... (прежние элементы toolbar) ... -->
    </div>

    <canvas id="canvas"></canvas>
    <div class="status-bar">
        <!-- ... (прежний статус-бар) ... -->
    </div>

<script>
"use strict";
class Editor {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.state = {
            elements: [],
            selected: new Set(),
            offset: { x: 0, y: 0 },
            scale: 1,
            grid: {
                size: 20,
                visible: true,
                color: '#eee'
            },
            currentTool: 'select',
            isDragging: false,
            dragType: null,
            startPos: { x: 0, y: 0 },
            currentElement: null,
            elementStartPositions: new Map()
        };

        this.initCanvas();
        this.initEventListeners();
        this.initGridControls();
        this.draw();
    }

    initGridControls() {
        const gridSizeInput = document.getElementById('gridSize');
        const toggleGridBtn = document.getElementById('toggleGrid');

        gridSizeInput.addEventListener('change', () => {
            this.state.grid.size = parseInt(gridSizeInput.value);
            this.draw();
        });

        toggleGridBtn.addEventListener('click', () => {
            this.state.grid.visible = !this.state.grid.visible;
            toggleGridBtn.textContent = `Сетка: ${this.state.grid.visible ? 'Вкл' : 'Выкл'}`;
            this.draw();
        });
    }

    // ... (методы initCanvas, initEventListeners без изменений) ...

    startNewElement(pos) {
        const snappedPos = this.snapToGrid(pos);
        this.state.currentElement = {
            id: Date.now(),
            type: this.state.currentTool,
            x1: snappedPos.x,
            y1: snappedPos.y,
            x2: snappedPos.x,
            y2: snappedPos.y
        };
    }

    updateCurrentElement(pos) {
        const el = this.state.currentElement;
        if (!el) return;

        const snappedPos = this.snapToGrid(pos);
        el.x2 = snappedPos.x;
        el.y2 = snappedPos.y;

        if (el.type === 'circle') {
            el.radius = Math.hypot(el.x2 - el.x1, el.y2 - el.y1);
        }
    }

    snapToGrid(pos) {
        if (!this.state.grid.visible) return pos;
        const size = this.state.grid.size;
        return {
            x: Math.round(pos.x / size) * size,
            y: Math.round(pos.y / size) * size
        };
    }

    checkCollision(el, pos) {
        switch(el.type) {
            case 'line':
                return this.pointNearLine(pos, el);
            case 'rect':
                return pos.x >= Math.min(el.x1, el.x2) && 
                       pos.x <= Math.max(el.x1, el.x2) && 
                       pos.y >= Math.min(el.y1, el.y2) && 
                       pos.y <= Math.max(el.y1, el.y2);
            case 'circle':
                return Math.hypot(pos.x - el.x1, pos.y - el.y1) <= el.radius;
            default:
                return false;
        }
    }

    pointNearLine(pos, line) {
        const dx = line.x2 - line.x1;
        const dy = line.y2 - line.y1;
        const length = Math.hypot(dx, dy);
        if (length === 0) return false;

        const t = ((pos.x - line.x1) * dx + (pos.y - line.y1) * dy) / (length * length);
        const nearestX = line.x1 + t * dx;
        const nearestY = line.y1 + t * dy;
        const dist = Math.hypot(pos.x - nearestX, pos.y - nearestY);
        
        return dist < 5 && t >= 0 && t <= 1;
    }

    moveSelectedElements(pos) {
        const delta = {
            x: (pos.x - this.state.startPos.x),
            y: (pos.y - this.state.startPos.y)
        };

        this.state.elements = this.state.elements.map(el => {
            if (!this.state.selected.has(el.id)) return el;
            
            const start = this.state.elementStartPositions.get(el.id);
            return {
                ...el,
                x1: start.x1 + delta.x,
                y1: start.y1 + delta.y,
                x2: start.x2 + delta.x,
                y2: start.y2 + delta.y
            };
        });
    }

    drawGrid() {
        if (!this.state.grid.visible) return;

        const ctx = this.ctx;
        const size = this.state.grid.size;
        const width = this.canvas.width / this.state.scale;
        const height = this.canvas.height / this.state.scale;
        const offsetX = this.state.offset.x % (size * this.state.scale);
        const offsetY = this.state.offset.y % (size * this.state.scale);

        ctx.strokeStyle = this.state.grid.color;
        ctx.lineWidth = 0.5;

        // Вертикальные линии
        for (let x = -offsetX; x < width; x += size) {
            ctx.beginPath();
            ctx.moveTo(x, -offsetY);
            ctx.lineTo(x, height);
            ctx.stroke();
        }

        // Горизонтальные линии
        for (let y = -offsetY; y < height; y += size) {
            ctx.beginPath();
            ctx.moveTo(-offsetX, y);
            ctx.lineTo(width, y);
            ctx.stroke();
        }
    }

    draw() {
        this.ctx.save();
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Рисуем сетку
        this.ctx.save();
        this.ctx.translate(this.state.offset.x, this.state.offset.y);
        this.ctx.scale(this.state.scale, this.state.scale);
        this.drawGrid();
        this.ctx.restore();

        // Рисуем элементы
        this.ctx.save();
        this.ctx.translate(this.state.offset.x, this.state.offset.y);
        this.ctx.scale(this.state.scale, this.state.scale);

        this.state.elements.forEach(el => {
            this.ctx.beginPath();
            this.ctx.strokeStyle = this.state.selected.has(el.id) ? '#f44336' : '#2196F3';
            this.ctx.lineWidth = 2;

            switch(el.type) {
                case 'line':
                    this.ctx.moveTo(el.x1, el.y1);
                    this.ctx.lineTo(el.x2, el.y2);
                    break;
                case 'rect':
                    this.ctx.rect(
                        Math.min(el.x1, el.x2),
                        Math.min(el.y1, el.y2),
                        Math.abs(el.x2 - el.x1),
                        Math.abs(el.y2 - el.y1)
                    );
                    break;
                case 'circle':
                    this.ctx.arc(el.x1, el.y1, el.radius, 0, Math.PI*2);
                    break;
            }
            this.ctx.stroke();
        });

        // Рисуем текущий элемент
        if (this.state.currentElement) {
            this.ctx.beginPath();
            this.ctx.strokeStyle = '#2196F3';
            this.ctx.setLineDash([5, 5]);
            
            const el = this.state.currentElement;
            switch(el.type) {
                case 'line':
                    this.ctx.moveTo(el.x1, el.y1);
                    this.ctx.lineTo(el.x2, el.y2);
                    break;
                case 'rect':
                    this.ctx.rect(
                        Math.min(el.x1, el.x2),
                        Math.min(el.y1, el.y2),
                        Math.abs(el.x2 - el.x1),
                        Math.abs(el.y2 - el.y1)
                    );
                    break;
                case 'circle':
                    this.ctx.arc(el.x1, el.y1, el.radius, 0, Math.PI*2);
                    break;
            }
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        }

        this.ctx.restore();
        this.ctx.restore();
    }

    // ... (остальные методы без изменений) ...
}

window.addEventListener('DOMContentLoaded', () => {
    new Editor();
});
</script>
</body>
</html>
