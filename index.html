<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <title>Топографический редактор PRO</title>
  <style>
    /* ... (предыдущие стили остаются без изменений) ... */
    
    /* Добавляем курсор для перемещения */
    canvas.move-cursor {
      cursor: grab;
    }
    canvas.move-cursor:active {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <!-- ... (HTML остаётся без изменений) ... -->

  <script>
    // ========== КОНФИГУРАЦИЯ ==========
    const CONFIG = {
      INIT_WIDTH: 2500,
      INIT_HEIGHT: 1500,
      GRID_COLOR: '#e0e0e0',
      MARGIN: 200 // Отступ для автоматического расширения холста
    };

    // ========== ИНИЦИАЛИЗАЦИЯ ==========
    const canvas = document.getElementById('sheet');
    const ctx = canvas.getContext('2d');
    const textInput = document.getElementById('text-input');
    
    // Начальные размеры холста
    canvas.width = CONFIG.INIT_WIDTH;
    canvas.height = CONFIG.INIT_HEIGHT;

    let state = {
      // ... (остальные поля остаются без изменений) ...
      isMovingCanvas: false,
      canvasOffset: { x: 0, y: 0 },
      lastMousePos: { x: 0, y: 0 },
      isMovingElement: false,
      originalElementPos: null
    };

    // ========== ОСНОВНЫЕ ФУНКЦИИ ==========
    function drawGrid() {
      if (!state.grid.enabled) return;
      
      ctx.save();
      ctx.translate(state.canvasOffset.x, state.canvasOffset.y);
      
      ctx.strokeStyle = state.grid.color;
      ctx.lineWidth = 1;
      
      // Вертикальные линии
      for (let x = 0; x <= canvas.width; x += state.grid.step) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      
      // Горизонтальные линии
      for (let y = 0; y <= canvas.height; y += state.grid.step) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
      
      ctx.restore();
    }

    // Автоматическое расширение холста
    function expandCanvasIfNeeded(x, y) {
      let needExpand = false;
      let newWidth = canvas.width;
      let newHeight = canvas.height;
      
      // Проверяем выход за границы
      if (x < CONFIG.MARGIN) {
        const expand = CONFIG.MARGIN - x;
        newWidth += expand;
        state.canvasOffset.x += expand;
        needExpand = true;
      } else if (x > canvas.width - CONFIG.MARGIN) {
        newWidth = x + CONFIG.MARGIN;
        needExpand = true;
      }
      
      if (y < CONFIG.MARGIN) {
        const expand = CONFIG.MARGIN - y;
        newHeight += expand;
        state.canvasOffset.y += expand;
        needExpand = true;
      } else if (y > canvas.height - CONFIG.MARGIN) {
        newHeight = y + CONFIG.MARGIN;
        needExpand = true;
      }
      
      if (needExpand) {
        // Создаем временный холст для переноса содержимого
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = newWidth;
        tempCanvas.height = newHeight;
        
        // Копируем содержимое
        tempCtx.drawImage(canvas, 
          state.canvasOffset.x, 
          state.canvasOffset.y,
          canvas.width, 
          canvas.height
        );
        
        // Обновляем основной холст
        canvas.width = newWidth;
        canvas.height = newHeight;
        ctx.drawImage(tempCanvas, 0, 0);
        
        renderCanvas();
      }
    }

    function renderElements() {
      ctx.save();
      ctx.translate(state.canvasOffset.x, state.canvasOffset.y);
      
      state.elements.forEach((el, index) => {
        ctx.beginPath();
        ctx.strokeStyle = el.color;
        ctx.fillStyle = el.color;
        ctx.lineWidth = 2;
        
        // Отрисовка самого элемента
        if (el.type === 'line') {
          ctx.moveTo(el.x1, el.y1);
          ctx.lineTo(el.x2, el.y2);
          ctx.stroke();
        } else if (el.type === 'rect') {
          ctx.rect(el.x1, el.y1, el.x2 - el.x1, el.y2 - el.y1);
          ctx.stroke();
        } else if (el.type === 'circle') {
          const radius = Math.sqrt(
            Math.pow(el.x2 - el.x1, 2) + 
            Math.pow(el.y2 - el.y1, 2)
          );
          ctx.arc(el.x1, el.y1, radius, 0, Math.PI * 2);
          ctx.stroke();
        } else if (el.type === 'text') {
          ctx.font = '16px Arial';
          ctx.fillText(el.content, el.x, el.y);
        }
        
        // Отрисовка выделения
        if (index === state.selectedElement) {
          ctx.strokeStyle = '#1a73e8';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 3]);
          
          if (el.type === 'line') {
            ctx.beginPath();
            ctx.moveTo(el.x1, el.y1);
            ctx.lineTo(el.x2, el.y2);
            ctx.stroke();
            
            // Маркеры для линии
            ctx.setLineDash([]);
            ctx.fillStyle = '#1a73e8';
            ctx.beginPath();
            ctx.arc(el.x1, el.y1, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(el.x2, el.y2, 4, 0, Math.PI * 2);
            ctx.fill();
          } else if (el.type === 'rect') {
            ctx.beginPath();
            ctx.rect(el.x1, el.y1, el.x2 - el.x1, el.y2 - el.y1);
            ctx.stroke();
            
            // Маркеры для прямоугольника
            ctx.setLineDash([]);
            ctx.fillStyle = '#1a73e8';
            const handles = [
              { x: el.x1, y: el.y1 },
              { x: (el.x1 + el.x2)/2, y: el.y1 },
              { x: el.x2, y: el.y1 },
              { x: el.x2, y: (el.y1 + el.y2)/2 },
              { x: el.x2, y: el.y2 },
              { x: (el.x1 + el.x2)/2, y: el.y2 },
              { x: el.x1, y: el.y2 },
              { x: el.x1, y: (el.y1 + el.y2)/2 }
            ];
            
            handles.forEach(handle => {
              ctx.beginPath();
              ctx.arc(handle.x, handle.y, 4, 0, Math.PI * 2);
              ctx.fill();
            });
          } else if (el.type === 'circle') {
            const radius = Math.sqrt(
              Math.pow(el.x2 - el.x1, 2) + 
              Math.pow(el.y2 - el.y1, 2)
            );
            ctx.beginPath();
            ctx.arc(el.x1, el.y1, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Маркеры для круга
            ctx.setLineDash([]);
            ctx.fillStyle = '#1a73e8';
            const angleStep = Math.PI/4;
            for (let i = 0; i < 8; i++) {
              const angle = i * angleStep;
              const hx = el.x1 + radius * Math.cos(angle);
              const hy = el.y1 + radius * Math.sin(angle);
              ctx.beginPath();
              ctx.arc(hx, hy, 4, 0, Math.PI * 2);
              ctx.fill();
            }
          } else if (el.type === 'text') {
            ctx.strokeText(el.content, el.x, el.y);
            ctx.setLineDash([]);
            ctx.fillStyle = '#1a73e8';
            ctx.beginPath();
            ctx.arc(el.x, el.y, 4, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      });
      
      ctx.restore();
    }

    // ========== ОБРАБОТЧИКИ СОБЫТИЙ ==========
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left - state.canvasOffset.x;
      const y = e.clientY - rect.top - state.canvasOffset.y;
      
      state.lastMousePos = { x: e.clientX, y: e.clientY };

      if (state.currentTool === 'select') {
        // Проверяем клик по маркеру трансформации
        if (state.selectedElement !== null) {
          state.resizeHandle = getResizeHandle(x, y, state.elements[state.selectedElement]);
          if (state.resizeHandle) {
            state.isResizing = true;
            state.startX = x;
            state.startY = y;
            return;
          }
        }
        
        // Проверяем клик по элементу
        state.selectedElement = null;
        for (let i = state.elements.length - 1; i >= 0; i--) {
          const el = state.elements[i];
          if (isPointInElement(x, y, el)) {
            state.selectedElement = i;
            state.isMovingElement = true;
            state.originalElementPos = {
              x1: el.x1, y1: el.y1,
              x2: el.x2 || 0, y2: el.y2 || 0,
              x: el.x || 0, y: el.y || 0
            };
            break;
          }
        }
        
        // Если не кликнули по элементу - начинаем перемещение холста
        if (state.selectedElement === null && !state.isResizing) {
          state.isMovingCanvas = true;
          canvas.classList.add('move-cursor');
        }
        
        renderCanvas();
        return;
      }

      // ... (остальные обработчики инструментов остаются без изменений) ...
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left - state.canvasOffset.x;
      const y = e.clientY - rect.top - state.canvasOffset.y;
      
      // Перемещение холста
      if (state.isMovingCanvas) {
        const dx = e.clientX - state.lastMousePos.x;
        const dy = e.clientY - state.lastMousePos.y;
        
        state.canvasOffset.x += dx;
        state.canvasOffset.y += dy;
        state.lastMousePos = { x: e.clientX, y: e.clientY };
        
        renderCanvas();
        return;
      }
      
      // Перемещение элемента
      if (state.isMovingElement && state.selectedElement !== null) {
        const element = state.elements[state.selectedElement];
        const dx = x - state.startX;
        const dy = y - state.startY;
        
        if (element.type === 'text') {
          element.x = state.originalElementPos.x + dx;
          element.y = state.originalElementPos.y + dy;
        } else {
          element.x1 = state.originalElementPos.x1 + dx;
          element.y1 = state.originalElementPos.y1 + dy;
          if (element.x2 !== undefined) element.x2 = state.originalElementPos.x2 + dx;
          if (element.y2 !== undefined) element.y2 = state.originalElementPos.y2 + dy;
        }
        
        expandCanvasIfNeeded(
          Math.max(element.x1, element.x2 || 0, element.x || 0),
          Math.max(element.y1, element.y2 || 0, element.y || 0)
        );
        
        renderCanvas();
        return;
      }

      // ... (остальные обработчики перемещения остаются без изменений) ...
    });

    canvas.addEventListener('mouseup', () => {
      state.isDrawing = false;
      state.isResizing = false;
      state.isMovingCanvas = false;
      state.isMovingElement = false;
      state.resizeHandle = null;
      canvas.classList.remove('move-cursor');
      saveToLocalStorage();
    });

    // Проверка попадания точки в элемент
    function isPointInElement(x, y, element) {
      if (element.type === 'line') {
        return distanceToLine(x, y, element.x1, element.y1, element.x2, element.y2) < 10;
      } else if (element.type === 'rect') {
        return x >= Math.min(element.x1, element.x2) && 
               x <= Math.max(element.x1, element.x2) &&
               y >= Math.min(element.y1, element.y2) && 
               y <= Math.max(element.y1, element.y2);
      } else if (element.type === 'circle') {
        const radius = Math.sqrt(
          Math.pow(element.x2 - element.x1, 2) + 
          Math.pow(element.y2 - element.y1, 2)
        );
        return Math.sqrt(Math.pow(x - element.x1, 2) + Math.pow(y - element.y1, 2)) <= radius + 5;
      } else if (element.type === 'text') {
        ctx.font = '16px Arial';
        const width = ctx.measureText(element.content).width;
        return x >= element.x - 5 && 
               x <= element.x + width + 5 &&
               y >= element.y - 16 && 
               y <= element.y + 5;
      }
      return false;
    }

    // Обновленный обработчик горячих клавиш
    document.addEventListener('keydown', (e) => {
      // Копирование
      if (e.ctrlKey && e.key === 'c' && state.selectedElement !== null) {
        e.preventDefault();
        state.clipboard = JSON.parse(JSON.stringify(state.elements[state.selectedElement]));
        console.log('Элемент скопирован в буфер');
      }
      
      // Вставка
      if (e.ctrlKey && e.key === 'v' && state.clipboard) {
        e.preventDefault();
        saveToUndoStack();
        
        const newElement = JSON.parse(JSON.stringify(state.clipboard));
        newElement.id = Date.now() + Math.random().toString(36).substr(2, 5);
        
        // Смещаем новый элемент
        if (newElement.type === 'text') {
          newElement.x += 20;
          newElement.y += 20;
        } else {
          newElement.x1 += 20;
          newElement.y1 += 20;
          if (newElement.x2) newElement.x2 += 20;
          if (newElement.y2) newElement.y2 += 20;
        }
        
        state.elements.push(newElement);
        state.selectedElement = state.elements.length - 1;
        
        saveToLocalStorage();
        renderCanvas();
      }
      
      // ... (остальные горячие клавиши остаются без изменений) ...
    });

    // ========== ЭКСПОРТ ==========
    function exportToPNG() {
      // Находим границы всех элементов
      let minX = Infinity, minY = Infinity;
      let maxX = -Infinity, maxY = -Infinity;
      
      state.elements.forEach(el => {
        if (el.type === 'text') {
          minX = Math.min(minX, el.x);
          minY = Math.min(minY, el.y);
          maxX = Math.max(maxX, el.x + ctx.measureText(el.content).width);
          maxY = Math.max(maxY, el.y + 16);
        } else {
          minX = Math.min(minX, el.x1, el.x2 || el.x1);
          minY = Math.min(minY, el.y1, el.y2 || el.y1);
          maxX = Math.max(maxX, el.x1, el.x2 || el.x1);
          maxY = Math.max(maxY, el.y1, el.y2 || el.y1);
        }
      });
      
      // Добавляем отступы
      const padding = 20;
      minX = Math.max(0, minX - padding);
      minY = Math.max(0, minY - padding);
      maxX = Math.min(canvas.width, maxX + padding);
      maxY = Math.min(canvas.height, maxY + padding);
      
      const width = maxX - minX;
      const height = maxY - minY;
      
      // Создаем временный холст
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = width;
      tempCanvas.height = height;
      
      // Заливаем белым фоном
      tempCtx.fillStyle = 'white';
      tempCtx.fillRect(0, 0, width, height);
      
      // Рисуем сетку
      if (state.grid.enabled) {
        tempCtx.strokeStyle = state.grid.color;
        tempCtx.lineWidth = 1;
        
        const startX = Math.floor(minX / state.grid.step) * state.grid.step;
        const startY = Math.floor(minY / state.grid.step) * state.grid.step;
        
        for (let x = startX; x <= maxX; x += state.grid.step) {
          tempCtx.beginPath();
          tempCtx.moveTo(x - minX, 0);
          tempCtx.lineTo(x - minX, height);
          tempCtx.stroke();
        }
        
        for (let y = startY; y <= maxY; y += state.grid.step) {
          tempCtx.beginPath();
          tempCtx.moveTo(0, y - minY);
          tempCtx.lineTo(width, y - minY);
          tempCtx.stroke();
        }
      }
      
      // Рисуем элементы
      state.elements.forEach(el => {
        tempCtx.save();
        tempCtx.translate(-minX, -minY);
        
        tempCtx.strokeStyle = el.color;
        tempCtx.fillStyle = el.color;
        tempCtx.lineWidth = 2;
        
        if (el.type === 'line') {
          tempCtx.beginPath();
          tempCtx.moveTo(el.x1, el.y1);
          tempCtx.lineTo(el.x2, el.y2);
          tempCtx.stroke();
        } else if (el.type === 'rect') {
          tempCtx.beginPath();
          tempCtx.rect(el.x1, el.y1, el.x2 - el.x1, el.y2 - el.y1);
          tempCtx.stroke();
        } else if (el.type === 'circle') {
          const radius = Math.sqrt(
            Math.pow(el.x2 - el.x1, 2) + 
            Math.pow(el.y2 - el.y1, 2)
          );
          tempCtx.beginPath();
          tempCtx.arc(el.x1, el.y1, radius, 0, Math.PI * 2);
          tempCtx.stroke();
        } else if (el.type === 'text') {
          tempCtx.font = '16px Arial';
          tempCtx.fillText(el.content, el.x, el.y);
        }
        
        tempCtx.restore();
      });
      
      // Создаем ссылку для скачивания
      tempCanvas.toBlob(blob => {
        const link = document.createElement('a');
        link.download = `${state.sheets[state.currentSheet].name}.png`;
        link.href = URL.createObjectURL(blob);
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        setTimeout(() => URL.revokeObjectURL(link.href), 100);
      }, 'image/png', 1.0);
    }

    // ... (остальной код остаётся без изменений) ...
  </script>
</body>
</html>
