<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DgrmJS (Full)</title>
    <style>
        /* === PART 0: CSS (must be first) === */
        body { margin:0; overflow:hidden; font-family:Arial; }
        #app { display:flex; flex-direction:column; height:100vh; }
        #toolbar { background:#f0f0f0; padding:8px; gap:8px; display:flex; }
        #canvas-container { flex:1; position:relative; overflow:auto; background:#f9f9f9; }
        #svg-container { position:absolute; width:100%; height:100%; }
        .shape { cursor:move; }
        rect, circle { stroke:#333; stroke-width:2; fill:white; }
    </style>
</head>
<body>
    <div id="app">
        <div id="toolbar"></div>
        <div id="canvas-container">
            <svg id="svg-container" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
    </div>

    <!-- === PART 1: CORE (Vector/Shape) === -->
    <script>
        class Vector {
            constructor(x=0, y=0) { this.x=x; this.y=y; }
            add(v) { return new Vector(this.x+v.x, this.y+v.y); }
            subtract(v) { return new Vector(this.x-v.x, this.y-v.y); }
            multiply(s) { return new Vector(this.x*s, this.y*s); }
            equals(v) { return this.x===v.x && this.y===v.y; }
            distanceTo(v) { return Math.sqrt((this.x-v.x)**2 + (this.y-v.y)**2); }
            toString() { return `(${this.x},${this.y})`; }
            clone() { return new Vector(this.x, this.y); }
            static fromEvent(e, svg) {
                const pt = svg.createSVGPoint();
                pt.x=e.clientX; pt.y=e.clientY;
                return new Vector(pt.x, pt.y);
            }
        }

        class Shape {
            constructor(type, pos, size, text="") {
                this.id=`shape_${Math.random().toString(36).substr(2,9)}`;
                this.type=type; this.position=pos.clone(); 
                this.size=size.clone(); this.text=text;
                this.rotation=0; this.zIndex=0;
                this.strokeColor="#333"; this.fillColor="#fff";
            }
            clone() {
                const s=new Shape(this.type,this.position,this.size,this.text);
                s.rotation=this.rotation; s.zIndex=this.zIndex;
                return s;
            }
            get center() {
                return new Vector(
                    this.position.x+this.size.x/2,
                    this.position.y+this.size.y/2
                );
            }
        }
    </script>

    <!-- === PART 2: Renderer === -->
    <script>
        class SVGRenderer {
            constructor(svg) { this.svg=svg; this.defs=null; }
            init() {
                this.defs=document.createElementNS('http://www.w3.org/2000/svg','defs');
                this.svg.appendChild(this.defs);
            }
            clear() { this.svg.innerHTML=''; }
            drawShape(shape) {
                const g=document.createElementNS('http://www.w3.org/2000/svg','g');
                g.setAttribute('class','shape'); g.setAttribute('data-id',shape.id);
                
                const rect=document.createElementNS('http://www.w3.org/2000/svg','rect');
                rect.setAttribute('x',shape.position.x);
                rect.setAttribute('y',shape.position.y);
                rect.setAttribute('width',shape.size.x);
                rect.setAttribute('height',shape.size.y);
                rect.setAttribute('fill',shape.fillColor);
                rect.setAttribute('stroke',shape.strokeColor);
                g.appendChild(rect);
                
                if(shape.text) {
                    const text=document.createElementNS('http://www.w3.org/2000/svg','text');
                    text.setAttribute('x',shape.position.x+shape.size.x/2);
                    text.setAttribute('y',shape.position.y+shape.size.y/2);
                    text.setAttribute('text-anchor','middle');
                    text.setAttribute('dominant-baseline','middle');
                    text.textContent=shape.text;
                    g.appendChild(text);
                }
                return g;
            }
        }
    </script>

    <!-- === PART 3-N: Остальные компоненты... === -->
    <!-- ... (здесь должны быть остальные части) ... -->

    <!-- === FINAL PART: Init === -->
    <script>
        document.addEventListener("DOMContentLoaded",()=>{
            console.log("DgrmJS initialized");
        });
    </script>
</body>
</html>
<!-- PART 3 START -->
<script>
class Tool {
    constructor(app) { this.app = app; }
    onMouseDown(e) {}
    onMouseMove(e) {}
    onMouseUp(e) {}
}

class SelectTool extends Tool {
    constructor(app) { super(app); }
    onMouseDown(e) {
        const pos = Vector.fromEvent(e, this.app.svg);
        this.selectionStart = pos;
        // Логика выделения будет добавлена в части 5
    }
}

class RectangleTool extends Tool {
    constructor(app) { super(app); }
    onMouseDown(e) {
        const pos = Vector.fromEvent(e, this.app.svg);
        const newShape = new Shape(
            'rectangle',
            pos,
            new Vector(100, 60),
            'New Rect'
        );
        this.app.addShape(newShape);
    }
}
</script>
<!-- PART 3 END -->
<!-- PART 4 START -->
<script>
class StateManager {
    constructor() {
        this.states = [];
        this.currentState = -1;
    }
    
    pushState(state) {
        this.states = this.states.slice(0, this.currentState + 1);
        this.states.push(state);
        this.currentState++;
    }
    
    undo() {
        if (this.currentState > 0) {
            this.currentState--;
            return this.states[this.currentState];
        }
        return null;
    }
    
    redo() {
        if (this.currentState < this.states.length - 1) {
            this.currentState++;
            return this.states[this.currentState];
        }
        return null;
    }
}
</script>
<!-- PART 4 END -->
<!-- PART 5 START -->
<script>
class SelectionManager {
    constructor(app) {
        this.app = app;
        this.selectedShapes = [];
        this.selectionBox = null;
    }
    
    selectShape(shape) {
        this.selectedShapes.push(shape);
        this.highlightShape(shape);
    }
    
    highlightShape(shape) {
        const element = this.app.svg.querySelector(`[data-id="${shape.id}"]`);
        if (element) {
            element.setAttribute('stroke', '#1a73e8');
            element.setAttribute('stroke-width', '3');
        }
    }
}
</script>
<!-- PART 5 END -->
<!-- PART 6 START -->
<script>
class TransformHandles {
    constructor(shape) {
        this.shape = shape;
        this.handles = [
            { position: 'nw', x: 0, y: 0 },
            { position: 'ne', x: 1, y: 0 },
            // ... все 8 точек трансформации
        ];
    }
    
    createHandles() {
        this.handles.forEach(handle => {
            const handleEl = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            handleEl.setAttribute('class', 'resize-handle');
            handleEl.setAttribute('r', '5');
            // ... позиционирование
        });
    }
}
</script>
<!-- PART 6 END -->
<!-- PART 7 START -->
<script>
class Connection {
    constructor(source, target, sourcePoint, targetPoint) {
        this.id = `conn_${Math.random().toString(36).substr(2,9)}`;
        this.source = source;
        this.target = target;
        this.sourcePoint = sourcePoint;
        this.targetPoint = targetPoint;
        this.path = '';
    }

    updatePath() {
        const sp = this.sourcePoint;
        const tp = this.targetPoint;
        this.path = `M${sp.x},${sp.y} L${tp.x},${tp.y}`;
    }
}

class ConnectionManager {
    constructor(app) {
        this.app = app;
        this.connections = [];
        this.tempConnection = null;
    }

    startConnection(source, point) {
        this.tempConnection = new Connection(source, null, point, point);
    }
}
</script>
<!-- PART 7 END -->
<!-- PART 8 START -->
<script>
class TextEditor {
    constructor(app) {
        this.app = app;
        this.currentEditElement = null;
        this.textInput = document.createElement('textarea');
        Object.assign(this.textInput.style, {
            position: 'absolute',
            display: 'none',
            background: 'transparent',
            border: '1px dashed #1a73e8',
            padding: '4px',
            font: '12px Arial'
        });
        document.body.appendChild(this.textInput);
    }

    startEditing(shape, svgTextElement) {
        const bbox = svgTextElement.getBBox();
        this.textInput.value = shape.text;
        Object.assign(this.textInput.style, {
            display: 'block',
            left: `${bbox.x}px`,
            top: `${bbox.y}px`,
            width: `${bbox.width}px`,
            height: `${bbox.height}px`
        });
        this.textInput.focus();
    }
}
</script>
<!-- PART 8 END -->
<!-- PART 9 START -->
<script>
class EventController {
    constructor(app) {
        this.app = app;
        this.currentTool = null;
        this.isDragging = false;
        this.dragStart = null;
        this.setupEvents();
    }

    setupEvents() {
        this.app.svg.addEventListener('mousedown', (e) => {
            if (this.currentTool) this.currentTool.onMouseDown(e);
        });

        document.addEventListener('mousemove', (e) => {
            if (this.isDragging) this.handleDrag(e);
        });

        document.addEventListener('mouseup', () => {
            this.isDragging = false;
        });
    }

    handleDrag(e) {
        // Логика перетаскивания
    }
}
</script>
<!-- PART 9 END -->
<!-- PART 10 START -->
<script>
class Diagram {
    constructor() {
        this.svg = document.getElementById('svg-container');
        this.renderer = new SVGRenderer(this.svg);
        this.stateManager = new StateManager();
        this.selectionManager = new SelectionManager(this);
        this.connectionManager = new ConnectionManager(this);
        this.textEditor = new TextEditor(this);
        this.eventController = new EventController(this);

        this.tools = {
            select: new SelectTool(this),
            rectangle: new RectangleTool(this),
            connector: new ConnectorTool(this)
        };

        this.setTool('select');
        this.renderer.init();
    }

    setTool(toolName) {
        this.eventController.currentTool = this.tools[toolName];
    }
}
</script>
<!-- PART 10 END -->
<!-- PART 11 START -->
<script>
class ConnectorTool extends Tool {
    constructor(app) { super(app); }

    onMouseDown(e) {
        const pos = Vector.fromEvent(e, this.app.svg);
        const shape = this.findShapeAtPosition(pos);
        if (shape) {
            this.app.connectionManager.startConnection(shape, pos);
        }
    }

    findShapeAtPosition(pos) {
        return this.app.shapes.find(shape => {
            return pos.x >= shape.position.x && 
                   pos.x <= shape.position.x + shape.size.x &&
                   pos.y >= shape.position.y && 
                   pos.y <= shape.position.y + shape.size.y;
        });
    }
}
</script>
<!-- PART 11 END -->
<!-- PART 12 START -->
<script>
class Serializer {
    static serialize(diagram) {
        return {
            shapes: diagram.shapes.map(shape => ({
                type: shape.type,
                position: { x: shape.position.x, y: shape.position.y },
                size: { x: shape.size.x, y: shape.size.y },
                text: shape.text,
                id: shape.id
            })),
            connections: diagram.connections.map(conn => ({
                source: conn.source.id,
                target: conn.target.id,
                sourcePoint: { x: conn.sourcePoint.x, y: conn.sourcePoint.y },
                targetPoint: { x: conn.targetPoint.x, y: conn.targetPoint.y }
            }))
        };
    }

    static deserialize(data, diagram) {
        const idMap = new Map();
        data.shapes.forEach(shapeData => {
            const shape = new Shape(
                shapeData.type,
                new Vector(shapeData.position.x, shapeData.position.y),
                new Vector(shapeData.size.x, shapeData.size.y),
                shapeData.text
            );
            idMap.set(shapeData.id, shape);
            diagram.addShape(shape);
        });

        data.connections.forEach(connData => {
            const conn = new Connection(
                idMap.get(connData.source),
                idMap.get(connData.target),
                new Vector(connData.sourcePoint.x, connData.sourcePoint.y),
                new Vector(connData.targetPoint.x, connData.targetPoint.y)
            );
            diagram.connections.push(conn);
        });
    }
}
</script>
<!-- PART 12 END -->
<!-- PART 13 START -->
<script>
class SVGExporter {
    static export(diagram) {
        const serializer = new XMLSerializer();
        const svgClone = diagram.svg.cloneNode(true);
        
        // Очистка временных элементов
        Array.from(svgClone.querySelectorAll('.resize-handle, .selection-box')).forEach(el => {
            el.parentNode.removeChild(el);
        });

        return serializer.serializeToString(svgClone);
    }

    static download(diagram, filename = 'diagram.svg') {
        const svgString = this.export(diagram);
        const blob = new Blob([svgString], { type: 'image/svg+xml' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
    }
}
</script>
<!-- PART 13 END -->
<!-- PART 14 START -->
<script>
class OperationHistory {
    constructor(diagram) {
        this.diagram = diagram;
        this.undoStack = [];
        this.redoStack = [];
        this.snapshot();
    }

    snapshot() {
        this.undoStack.push(Serializer.serialize(this.diagram));
        this.redoStack = [];
    }

    undo() {
        if (this.undoStack.length > 1) {
            this.redoStack.push(this.undoStack.pop());
            const state = this.undoStack[this.undoStack.length - 1];
            this.diagram.clear();
            Serializer.deserialize(state, this.diagram);
        }
    }
}
</script>
<!-- PART 14 END -->
<!-- PART 15 START -->
<script>
class ContextMenu {
    constructor(diagram) {
        this.diagram = diagram;
        this.menu = document.createElement('div');
        Object.assign(this.menu.style, {
            position: 'absolute',
            background: 'white',
            border: '1px solid #ddd',
            boxShadow: '2px 2px 5px rgba(0,0,0,0.2)',
            display: 'none',
            zIndex: 1000
        });

        this.addMenuItem('Delete', () => {
            diagram.selectionManager.deleteSelected();
        });

        document.body.appendChild(this.menu);
    }

    show(x, y) {
        this.menu.style.display = 'block';
        this.menu.style.left = `${x}px`;
        this.menu.style.top = `${y}px`;
    }
}
</script>
<!-- PART 15 END -->
<!-- PART 16 START -->
<script>
class LayerManager {
    constructor(diagram) {
        this.diagram = diagram;
        this.layers = [];
        this.currentLayer = null;
    }

    createLayer(name) {
        const layer = {
            id: `layer_${Date.now()}`,
            name: name || `Layer ${this.layers.length + 1}`,
            visible: true,
            shapes: []
        };
        this.layers.push(layer);
        return layer;
    }

    moveToLayer(shape, layer) {
        const currentLayer = this.findLayerForShape(shape);
        if (currentLayer) {
            currentLayer.shapes = currentLayer.shapes.filter(s => s.id !== shape.id);
        }
        layer.shapes.push(shape);
    }
}
</script>
<!-- PART 16 END -->
<!-- PART 17 START -->
<script>
class Diagram {
    // ... (дополнение к ранее отправленному классу)

    clear() {
        this.shapes = [];
        this.connections = [];
        this.renderer.clear();
    }

    addShape(shape) {
        this.shapes.push(shape);
        this.renderer.drawShape(shape);
        this.stateManager.snapshot();
    }

    deleteShape(shape) {
        this.shapes = this.shapes.filter(s => s.id !== shape.id);
        this.renderer.render(this.shapes, this.connections);
        this.stateManager.snapshot();
    }
}
</script>
<!-- PART 17 END -->
<!-- PART 18 START -->
<script>
class UIManager {
    static initToolbar(diagram) {
        const toolbar = document.getElementById('toolbar');
        
        const tools = [
            { name: 'Select', tool: 'select' },
            { name: 'Rectangle', tool: 'rectangle' },
            { name: 'Connector', tool: 'connector' },
            { name: 'Undo', action: () => diagram.stateManager.undo() },
            { name: 'Export SVG', action: () => SVGExporter.download(diagram) }
        ];

        tools.forEach(item => {
            const btn = document.createElement('button');
            btn.textContent = item.name;
            if (item.tool) {
                btn.addEventListener('click', () => diagram.setTool(item.tool));
            } else {
                btn.addEventListener('click', item.action);
            }
            toolbar.appendChild(btn);
        });
    }
}
</script>
<!-- PART 18 END -->
<!-- PART 19 START -->
<script>
document.addEventListener('DOMContentLoaded', () => {
    const diagram = new Diagram();
    window.diagram = diagram; // Для доступа из консоли
    
    UIManager.initToolbar(diagram);
    
    // Тестовые данные
    const shape1 = new Shape(
        'rectangle',
        new Vector(100, 100),
        new Vector(150, 100),
        'Shape 1'
    );
    
    diagram.addShape(shape1);
});
</script>
<!-- PART 19 END -->
<!-- PART 20 START -->
<style>
    /* Дополнительные стили */
    .resize-handle {
        fill: #1a73e8;
        cursor: nwse-resize;
        opacity: 0;
        transition: opacity 0.2s;
    }
    
    .shape:hover .resize-handle {
        opacity: 1;
    }
    
    .connection {
        stroke: #666;
        stroke-width: 2;
        fill: none;
    }
    
    .selection-box {
        stroke: #1a73e8;
        stroke-dasharray: 5,5;
        fill: rgba(26,115,232,0.1);
    }
</style>
<!-- PART 20 END -->
