<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <title>–¢–æ–ø–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π —Ä–µ–¥–∞–∫—Ç–æ—Ä PRO</title>
  <style>
    body { 
      margin: 0;
      font-family: Arial;
      background: #f5f5f5;
      overflow: hidden;
    }
    #app { 
      display: flex;
      height: 100vh;
    }
    #toolbar {
      width: 220px;
      background: #2c3e50;
      padding: 15px;
      color: white;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
      overflow-y: auto;
    }
    .tool-section {
      margin-bottom: 20px;
      border-bottom: 1px solid #34495e;
      padding-bottom: 15px;
    }
    .tool-section h3 {
      color: #1abc9c;
      margin-top: 0;
      text-align: center;
    }
    .tool-btn {
      display: block;
      margin: 8px 0;
      padding: 10px;
      width: 100%;
      background: #34495e;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
      text-align: left;
    }
    .tool-btn:hover {
      background: #3d5166;
      transform: translateY(-2px);
    }
    .tool-btn.active {
      background: #1abc9c;
      font-weight: bold;
    }
    #canvas-container {
      flex: 1;
      position: relative;
      overflow: auto;
      background: #ecf0f1;
    }
    canvas {
      display: block;
      background: white;
      box-shadow: 0 0 15px rgba(0,0,0,0.1);
      margin: 20px auto;
    }
    .tabs {
      display: flex;
      background: #34495e;
      padding: 8px 8px 0;
      flex-wrap: wrap;
    }
    .tab {
      padding: 8px 16px;
      margin: 0 4px 4px 0;
      background: #2c3e50;
      border-radius: 4px 4px 0 0;
      cursor: pointer;
      position: relative;
      color: white;
      transition: all 0.2s;
    }
    .tab:hover {
      background: #3d5166;
    }
    .tab.active {
      background: #1abc9c;
      font-weight: bold;
    }
    .tab-close {
      position: absolute;
      right: 5px;
      top: 5px;
      font-size: 12px;
      color: #e74c3c;
      background: white;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    .tab-edit {
      position: absolute;
      right: 25px;
      top: 5px;
      font-size: 12px;
      color: #3498db;
    }
    #text-input {
      position: absolute;
      border: 1px dashed #000;
      padding: 4px;
      display: none;
      background: white;
      z-index: 10;
      min-width: 100px;
      font-family: Arial;
      font-size: 16px;
    }
    #rename-dialog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 8px;
      border: 1px solid #ccc;
      box-shadow: 0 0 20px rgba(0,0,0,0.2);
      z-index: 100;
      display: none;
    }
    #rename-dialog h3 {
      margin-top: 0;
      color: #2c3e50;
    }
    #rename-dialog input {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    #rename-dialog button {
      padding: 8px 15px;
      margin-right: 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #rename-confirm {
      background: #1abc9c;
      color: white;
    }
    #rename-cancel {
      background: #e74c3c;
      color: white;
    }
    .grid-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .grid-controls label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: white;
    }
    .grid-controls input {
      width: 60px;
      padding: 5px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }
    #color-picker {
      width: 100%;
      height: 40px;
      margin: 10px 0;
      cursor: pointer;
      border: none;
      border-radius: 4px;
    }
    .shape-library {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-top: 10px;
    }
    .shape-btn {
      padding: 8px;
      background: #34495e;
      border: none;
      border-radius: 4px;
      color: white;
      cursor: pointer;
      transition: all 0.2s;
    }
    .shape-btn:hover {
      background: #3d5166;
    }
    .selection-box {
      position: absolute;
      border: 2px dashed #1abc9c;
      pointer-events: none;
      display: none;
    }
    .control-point {
      position: absolute;
      width: 8px;
      height: 8px;
      background: #1abc9c;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: all;
      cursor: move;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="toolbar">
      <div class="tool-section">
        <h3>–õ–∏—Å—Ç—ã</h3>
        <button id="new-sheet" class="tool-btn">+ –ù–æ–≤—ã–π –ª–∏—Å—Ç</button>
      </div>
      <div class="tool-section">
        <h3>–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã</h3>
        <button id="tool-select" class="tool-btn active">üñ±Ô∏è –í—ã–¥–µ–ª–µ–Ω–∏–µ</button>
        <button id="tool-line" class="tool-btn">‚úèÔ∏è –õ–∏–Ω–∏—è</button>
        <button id="tool-rect" class="tool-btn">‚¨ú –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫</button>
        <button id="tool-circle" class="tool-btn">üîµ –ö—Ä—É–≥</button>
        <button id="tool-text" class="tool-btn">üî§ –¢–µ–∫—Å—Ç</button>
      </div>
      <div class="tool-section">
        <h3>–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ —Ñ–∏–≥—É—Ä</h3>
        <div class="shape-library">
          <button class="shape-btn" data-shape="rectangle">–ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫</button>
          <button class="shape-btn" data-shape="circle">–ö—Ä—É–≥</button>
          <button class="shape-btn" data-shape="diamond">–†–æ–º–±</button>
          <button class="shape-btn" data-shape="triangle">–¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫</button>
          <button class="shape-btn" data-shape="hexagon">–®–µ—Å—Ç–∏—É–≥–æ–ª—å–Ω–∏–∫</button>
          <button class="shape-btn" data-shape="arrow">–°—Ç—Ä–µ–ª–∫–∞</button>
        </div>
      </div>
      <div class="tool-section">
        <h3>–°–≤–æ–π—Å—Ç–≤–∞</h3>
        <input type="color" id="color-picker" value="#000000">
        <label>
          –¢–æ–ª—â–∏–Ω–∞ –ª–∏–Ω–∏–∏:
          <input type="range" id="line-width" min="1" max="10" value="2">
        </label>
      </div>
      <div class="tool-section">
        <h3>–°–µ—Ç–∫–∞</h3>
        <div class="grid-controls">
          <button id="toggle-grid" class="tool-btn">–°–µ—Ç–∫–∞: –í–∫–ª</button>
          <button id="toggle-snap" class="tool-btn">–ü—Ä–∏–≤—è–∑–∫–∞: –í–∫–ª</button>
          <label>
            –®–∞–≥ —Å–µ—Ç–∫–∏:
            <input type="number" id="grid-step" value="20" min="10">
          </label>
        </div>
      </div>
      <div class="tool-section">
        <button id="clear-btn" class="tool-btn">‚ùå –û—á–∏—Å—Ç–∏—Ç—å –ª–∏—Å—Ç</button>
        <button id="export-btn" class="tool-btn">üíæ –≠–∫—Å–ø–æ—Ä—Ç PNG</button>
      </div>
    </div>
    <div id="canvas-container">
      <div class="tabs" id="sheet-tabs"></div>
      <canvas id="sheet"></canvas>
      <div id="text-input" contenteditable="true"></div>
      <div id="selection-box" class="selection-box"></div>
    </div>
  </div>

  <div id="rename-dialog">
    <h3>–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å –ª–∏—Å—Ç</h3>
    <input type="text" id="rename-input">
    <button id="rename-confirm">OK</button>
    <button id="rename-cancel">–û—Ç–º–µ–Ω–∞</button>
  </div>

  <script>
    // ========== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ==========
    const CONFIG = {
      CANVAS_WIDTH: 2500,
      CANVAS_HEIGHT: 1500,
      GRID_COLOR: '#e0e0e0',
      SHAPE_SNAP_TO_GRID: true,
      CONTROL_POINT_SIZE: 8
    };

    // ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ==========
    const canvas = document.getElementById('sheet');
    const ctx = canvas.getContext('2d');
    const textInput = document.getElementById('text-input');
    const selectionBox = document.getElementById('selection-box');
    canvas.width = CONFIG.CANVAS_WIDTH;
    canvas.height = CONFIG.CANVAS_HEIGHT;

    let state = {
      sheets: [],
      currentSheet: 0,
      currentTool: 'select',
      color: '#000000',
      lineWidth: 2,
      selectedElement: null,
      selectedControlPoint: null,
      undoStack: [],
      redoStack: [],
      grid: {
        enabled: true,
        snap: true,
        step: 20,
        color: CONFIG.GRID_COLOR
      },
      elements: [],
      renamingSheet: null,
      textInputActive: false,
      isDrawing: false,
      isDragging: false,
      startX: 0,
      startY: 0,
      dragOffsetX: 0,
      dragOffsetY: 0,
      controlPoints: []
    };

    // ========== –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò ==========
    function snapToGrid(value) {
      return state.grid.snap ? Math.round(value / state.grid.step) * state.grid.step : value;
    }

    function drawGrid() {
      if (!state.grid.enabled) return;
      ctx.strokeStyle = state.grid.color;
      ctx.lineWidth = 1;
      
      for (let x = 0; x <= canvas.width; x += state.grid.step) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      
      for (let y = 0; y <= canvas.height; y += state.grid.step) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    function saveToUndoStack() {
      state.undoStack.push(JSON.stringify({
        elements: JSON.parse(JSON.stringify(state.elements)),
        sheets: JSON.parse(JSON.stringify(state.sheets)),
        currentSheet: state.currentSheet
      }));
      if (state.undoStack.length > 50) state.undoStack.shift();
      state.redoStack = [];
    }

    function undo() {
      if (state.undoStack.length === 0) return;
      
      state.redoStack.push(JSON.stringify({
        elements: JSON.parse(JSON.stringify(state.elements)),
        sheets: JSON.parse(JSON.stringify(state.sheets)),
        currentSheet: state.currentSheet
      }));
      
      const prevState = JSON.parse(state.undoStack.pop());
      state.elements = prevState.elements;
      state.sheets = prevState.sheets;
      state.currentSheet = prevState.currentSheet;
      
      state.elements = state.sheets[state.currentSheet].elements;
      saveToLocalStorage();
      renderCanvas();
      renderTabs();
      
      if (state.textInputActive) {
        textInput.style.display = 'none';
        state.textInputActive = false;
      }
    }

    function createShape(shapeType, x, y, width = 100, height = 60) {
      const baseShape = {
        x1: x,
        y1: y,
        x2: x + width,
        y2: y + height,
        color: state.color,
        lineWidth: state.lineWidth
      };

      return { ...baseShape, type: shapeType };
    }
        function isPointInElement(x, y, element) {
      switch(element.type) {
        case 'line':
          return distanceToLine(x, y, element.x1, element.y1, element.x2, element.y2) < 10;
        case 'rectangle':
          return x >= Math.min(element.x1, element.x2) && 
                 x <= Math.max(element.x1, element.x2) &&
                 y >= Math.min(element.y1, element.y2) && 
                 y <= Math.max(element.y1, element.y2);
        case 'circle':
          const radius = Math.sqrt(Math.pow(element.x2 - element.x1, 2) + Math.pow(element.y2 - element.y1, 2));
          const dist = Math.sqrt(Math.pow(x - element.x1, 2) + Math.pow(y - element.y1, 2));
          return dist <= radius + 5;
        case 'diamond':
          const diamondCenterX = (element.x1 + element.x2) / 2;
          const diamondCenterY = (element.y1 + element.y2) / 2;
          const halfWidth = Math.abs(element.x2 - element.x1) / 2;
          const halfHeight = Math.abs(element.y2 - element.y1) / 2;
          const dx = Math.abs(x - diamondCenterX);
          const dy = Math.abs(y - diamondCenterY);
          return (dx / halfWidth + dy / halfHeight) <= 1;
        case 'triangle':
          const triangleMinX = Math.min(element.x1, element.x2);
          const triangleMaxX = Math.max(element.x1, element.x2);
          const triangleMinY = Math.min(element.y1, element.y2);
          const triangleMaxY = Math.max(element.y1, element.y2);
          const triangleCenterX = (element.x1 + element.x2) / 2;
          
          if (x < triangleMinX || x > triangleMaxX || y < triangleMinY || y > triangleMaxY) {
            return false;
          }
          
          const v0 = [triangleCenterX, triangleMinY];
          const v1 = [triangleMaxX, triangleMaxY];
          const v2 = [triangleMinX, triangleMaxY];
          
          const sign = (p1, p2, p3) => (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1]);
          
          const d1 = sign([x, y], v0, v1);
          const d2 = sign([x, y], v1, v2);
          const d3 = sign([x, y], v2, v0);
          
          const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
          const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);
          
          return !(hasNeg && hasPos);
        case 'hexagon':
          const hexCenterX = (element.x1 + element.x2) / 2;
          const hexCenterY = (element.y1 + element.y2) / 2;
          const hexSide = Math.min(Math.abs(element.x2 - element.x1), Math.abs(element.y2 - element.y1)) / 2;
          
          const px = x - hexCenterX;
          const py = y - hexCenterY;
          
          const angle = Math.atan2(py, px);
          const radius = hexSide / Math.cos(Math.PI / 6);
          const distance = Math.sqrt(px * px + py * py);
          
          return distance <= radius * Math.cos(Math.abs(angle) % (Math.PI / 3) - Math.PI / 6);
        case 'arrow':
          const arrowHeadSize = Math.min(Math.abs(element.x2 - element.x1), Math.abs(element.y2 - element.y1)) / 3;
          const angle = Math.atan2(element.y2 - element.y1, element.x2 - element.x1);
          
          if (distanceToLine(x, y, element.x1, element.y1, element.x2, element.y2) < 10) {
            return true;
          }
          
          const headPoint1 = {
            x: element.x2 - arrowHeadSize * Math.cos(angle - Math.PI / 6),
            y: element.y2 - arrowHeadSize * Math.sin(angle - Math.PI / 6)
          };
          
          const headPoint2 = {
            x: element.x2 - arrowHeadSize * Math.cos(angle + Math.PI / 6),
            y: element.y2 - arrowHeadSize * Math.sin(angle + Math.PI / 6)
          };
          
          return (
            distanceToLine(x, y, element.x2, element.y2, headPoint1.x, headPoint1.y) < 10 ||
            distanceToLine(x, y, element.x2, element.y2, headPoint2.x, headPoint2.y) < 10
          );
        case 'text':
          return x >= element.x - 5 && 
                 x <= element.x + ctx.measureText(element.content).width + 5 &&
                 y >= element.y - 16 && 
                 y <= element.y + 5;
        default:
          return false;
      }
    }

    function distanceToLine(x, y, x1, y1, x2, y2) {
      const A = x - x1;
      const B = y - y1;
      const C = x2 - x1;
      const D = y2 - y1;
      const dot = A * C + B * D;
      const len_sq = C * C + D * D;
      let param = -1;
      if (len_sq !== 0) param = dot / len_sq;
      let xx, yy;
      if (param < 0) {
        xx = x1;
        yy = y1;
      } else if (param > 1) {
        xx = x2;
        yy = y2;
      } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }
      return Math.sqrt((x - xx) ** 2 + (y - yy) ** 2);
    }

    function renderElements() {
      state.elements.forEach((el, index) => {
        ctx.beginPath();
        ctx.strokeStyle = el.color;
        ctx.fillStyle = el.color;
        ctx.lineWidth = el.lineWidth || state.lineWidth;
        
        switch(el.type) {
          case 'line':
            ctx.moveTo(el.x1, el.y1);
            ctx.lineTo(el.x2, el.y2);
            break;
          case 'rectangle':
            ctx.rect(el.x1, el.y1, el.x2 - el.x1, el.y2 - el.y1);
            break;
          case 'circle':
            const radius = Math.sqrt(Math.pow(el.x2 - el.x1, 2) + Math.pow(el.y2 - el.y1, 2));
            ctx.arc(el.x1, el.y1, radius, 0, Math.PI * 2);
            break;
          case 'diamond':
            const diamondCenterX = (el.x1 + el.x2) / 2;
            const diamondCenterY = (el.y1 + el.y2) / 2;
            ctx.moveTo(diamondCenterX, el.y1);
            ctx.lineTo(el.x2, diamondCenterY);
            ctx.lineTo(diamondCenterX, el.y2);
            ctx.lineTo(el.x1, diamondCenterY);
            ctx.closePath();
            break;
          case 'triangle':
            ctx.moveTo((el.x1 + el.x2) / 2, el.y1);
            ctx.lineTo(el.x2, el.y2);
            ctx.lineTo(el.x1, el.y2);
            ctx.closePath();
            break;
          case 'hexagon':
            const hexWidth = el.x2 - el.x1;
            const hexHeight = el.y2 - el.y1;
            const hexCenterX = el.x1 + hexWidth / 2;
            const hexCenterY = el.y1 + hexHeight / 2;
            const hexSide = Math.min(hexWidth, hexHeight) / 2;
            
            ctx.moveTo(hexCenterX + hexSide * Math.cos(0), hexCenterY + hexSide * Math.sin(0));
            for (let i = 1; i <= 6; i++) {
              ctx.lineTo(
                hexCenterX + hexSide * Math.cos(i * 2 * Math.PI / 6),
                hexCenterY + hexSide * Math.sin(i * 2 * Math.PI / 6)
              );
            }
            ctx.closePath();
            break;
          case 'arrow':
            const arrowHeadSize = Math.min(Math.abs(el.x2 - el.x1), Math.abs(el.y2 - el.y1)) / 3;
            const angle = Math.atan2(el.y2 - el.y1, el.x2 - el.x1);
            
            ctx.moveTo(el.x1, el.y1);
            ctx.lineTo(el.x2, el.y2);
            
            ctx.lineTo(
              el.x2 - arrowHeadSize * Math.cos(angle - Math.PI / 6),
              el.y2 - arrowHeadSize * Math.sin(angle - Math.PI / 6)
            );
            ctx.moveTo(el.x2, el.y2);
            ctx.lineTo(
              el.x2 - arrowHeadSize * Math.cos(angle + Math.PI / 6),
              el.y2 - arrowHeadSize * Math.sin(angle + Math.PI / 6)
            );
            break;
          case 'text':
            ctx.font = '16px Arial';
            ctx.fillText(el.content, el.x, el.y);
            break;
        }
        
        ctx.stroke();
        
        if (index === state.selectedElement) {
          ctx.strokeStyle = '#FF0000';
          ctx.lineWidth = (el.lineWidth || state.lineWidth) + 2;
          ctx.stroke();
          showControlPoints(el);
        }
      });
    }

    function showControlPoints(element) {
      clearControlPoints();
      
      if (!element) return;
      
      const points = [];
      
      switch(element.type) {
        case 'line':
          points.push({ x: element.x1, y: element.y1, type: 'start' });
          points.push({ x: element.x2, y: element.y2, type: 'end' });
          break;
        case 'rectangle':
        case 'diamond':
        case 'triangle':
        case 'hexagon':
          points.push({ x: element.x1, y: element.y1, type: 'top-left' });
          points.push({ x: element.x2, y: element.y1, type: 'top-right' });
          points.push({ x: element.x1, y: element.y2, type: 'bottom-left' });
          points.push({ x: element.x2, y: element.y2, type: 'bottom-right' });
          break;
        case 'circle':
          const radius = Math.sqrt(Math.pow(element.x2 - element.x1, 2) + Math.pow(element.y2 - element.y1, 2));
          points.push({ x: element.x1, y: element.y1 - radius, type: 'top' });
          points.push({ x: element.x1 + radius, y: element.y1, type: 'right' });
          points.push({ x: element.x1, y: element.y1 + radius, type: 'bottom' });
          points.push({ x: element.x1 - radius, y: element.y1, type: 'left' });
          break;
        case 'arrow':
          points.push({ x: element.x1, y: element.y1, type: 'start' });
          points.push({ x: element.x2, y: element.y2, type: 'end' });
          break;
      }
      
      points.forEach(point => {
        const cp = document.createElement('div');
        cp.className = 'control-point';
        cp.style.left = `${point.x}px`;
        cp.style.top = `${point.y}px`;
        cp.dataset.type = point.type;
        cp.dataset.elementIndex = state.selectedElement;
        
        cp.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          state.selectedControlPoint = {
            type: point.type,
            elementIndex: state.selectedElement
          };
          state.isDragging = true;
          state.dragOffsetX = e.clientX - point.x;
          state.dragOffsetY = e.clientY - point.y;
        });
        
        document.getElementById('canvas-container').appendChild(cp);
        state.controlPoints.push(cp);
      });
      
      updateSelectionBox(element);
    }

    function clearControlPoints() {
      state.controlPoints.forEach(cp => cp.remove());
      state.controlPoints = [];
      selectionBox.style.display = 'none';
    }

    function updateSelectionBox(element) {
      if (!element) return;
      
      let left, top, width, height;
      
      switch(element.type) {
        case 'line':
          left = Math.min(element.x1, element.x2);
          top = Math.min(element.y1, element.y2);
          width = Math.abs(element.x2 - element.x1);
          height = Math.abs(element.y2 - element.y1);
          break;
        case 'rectangle':
        case 'circle':
        case 'diamond':
        case 'triangle':
        case 'hexagon':
        case 'arrow':
          left = Math.min(element.x1, element.x2);
          top = Math.min(element.y1, element.y2);
          width = Math.abs(element.x2 - element.x1);
          height = Math.abs(element.y2 - element.y1);
          break;
        case 'text':
          const textWidth = ctx.measureText(element.content).width;
          left = element.x;
          top = element.y - 16;
          width = textWidth;
          height = 20;
          break;
        default:
          return;
      }
      
      const padding = 8;
      selectionBox.style.left = `${left - padding}px`;
      selectionBox.style.top = `${top - padding}px`;
      selectionBox.style.width = `${width + padding * 2}px`;
      selectionBox.style.height = `${height + padding * 2}px`;
      selectionBox.style.display = 'block';
    }

    function renderCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid();
      renderElements();
    }

    // ... (–æ—Å—Ç–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π, –∫–∞–∫ –≤ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≤–µ—Ä—Å–∏–∏)

    // ========== –ó–ê–ü–£–°–ö ==========
    loadFromLocalStorage();
    setActiveTool('select');
  </script>
</body>
</html>
