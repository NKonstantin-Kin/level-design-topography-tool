<script>
"use strict";
class Editor {
    constructor() {
        // ... остальная часть конструктора без изменений ...

        this.state = {
            elements: [],
            selected: new Set(),
            offset: { x: 0, y: 0 },
            scale: 1,
            currentTool: 'select',
            isDragging: false,
            isMovingView: false,
            startPos: { x: 0, y: 0 },
            currentElement: null,
            dragStart: { x: 0, y: 0 },
            elementStartPositions: []
        };
    }

    handleMouseDown(e) {
        const pos = this.getMousePos(e);
        this.state.isDragging = true;
        this.state.startPos = pos;
        this.state.dragStart = { ...pos };

        if(this.state.currentTool !== 'select') {
            // Инициализация нового элемента
            this.state.currentElement = {
                id: Date.now(),
                type: this.state.currentTool,
                x: pos.x,
                y: pos.y,
                width: 0,
                height: 0,
                radius: 0,
                color: '#2196F3'
            };
        } else {
            // Проверяем клик по элементу
            const clickedElement = this.findElementAt(pos);
            if(clickedElement) {
                if(!e.shiftKey) this.state.selected.clear();
                this.state.selected.add(clickedElement.id);
                this.saveElementStartPositions();
            } else {
                this.state.isMovingView = true;
                this.state.selected.clear();
            }
            this.updateSelectedInfo();
        }
        this.draw();
    }

    handleMouseMove(e) {
        const pos = this.getMousePos(e);
        this.updateCursorPos(pos);

        if(this.state.isDragging) {
            if(this.state.currentTool === 'select') {
                if(this.state.isMovingView) {
                    // Перемещение вида
                    this.state.offset.x += e.movementX;
                    this.state.offset.y += e.movementY;
                } else {
                    // Перемещение элементов
                    this.moveSelectedElements(pos);
                }
            } else {
                // Рисование нового элемента
                this.updateCurrentElement(pos);
            }
            this.draw();
        }
    }

    handleMouseUp() {
        if(this.state.currentElement) {
            // Финализация нового элемента
            this.finalizeCurrentElement();
        }
        this.state.isDragging = false;
        this.state.isMovingView = false;
        this.draw();
    }

    // Новые методы
    findElementAt(pos) {
        for(const element of this.state.elements) {
            if(this.checkCollision(element, pos)) {
                return element;
            }
        }
        return null;
    }

    saveElementStartPositions() {
        this.state.elementStartPositions = [];
        for(const element of this.state.elements) {
            if(this.state.selected.has(element.id)) {
                this.state.elementStartPositions.push({
                    id: element.id,
                    x: element.x,
                    y: element.y
                });
            }
        }
    }

    moveSelectedElements(pos) {
        const deltaX = pos.x - this.state.dragStart.x;
        const deltaY = pos.y - this.state.dragStart.y;
        
        this.state.elements = this.state.elements.map(element => {
            if(this.state.selected.has(element.id)) {
                const startPos = this.state.elementStartPositions.find(p => p.id === element.id);
                return {
                    ...element,
                    x: startPos.x + deltaX,
                    y: startPos.y + deltaY
                };
            }
            return element;
        });
    }

    finalizeCurrentElement() {
        // Корректируем координаты для отрицательных размеров
        const el = this.state.currentElement;
        if(el.type === 'rect') {
            el.x = Math.min(el.x, el.x + el.width);
            el.y = Math.min(el.y, el.y + el.height);
            el.width = Math.abs(el.width);
            el.height = Math.abs(el.height);
        }
        this.state.elements.push(el);
        this.state.currentElement = null;
    }

    checkCollision(element, pos) {
        if(!element) return false;
        
        switch(element.type) {
            case 'rect':
                return pos.x >= element.x && 
                       pos.x <= element.x + element.width &&
                       pos.y >= element.y && 
                       pos.y <= element.y + element.height;
            case 'circle':
                return Math.hypot(pos.x - element.x, pos.y - element.y) <= element.radius;
            case 'line':
                const dx = element.x2 - element.x1;
                const dy = element.y2 - element.y1;
                const t = ((pos.x - element.x1) * dx + (pos.y - element.y1) * dy) / (dx*dx + dy*dy);
                return t >= 0 && t <= 1;
        }
        return false;
    }

    // Обновленный метод рисования
    draw() {
        // ... остальная часть метода без изменений ...
        
        // Рисование выделения
        this.state.elements.forEach(element => {
            if(this.state.selected.has(element.id)) {
                this.ctx.strokeStyle = '#f44336';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(
                    element.x - 2, 
                    element.y - 2, 
                    element.width + 4, 
                    element.height + 4
                );
            }
        });
    }
}
</script>
