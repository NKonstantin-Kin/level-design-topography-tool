<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Топографический редактор</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            padding: 10px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #e3f2fd;
            border-color: #2196F3;
        }

        button.selected {
            background: #2196F3;
            color: white;
            border-color: #1976D2;
        }

        canvas {
            flex: 1;
            margin: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            touch-action: none;
        }

        .status-bar {
            padding: 8px 16px;
            background: white;
            border-top: 1px solid #ddd;
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <button id="selectTool" class="selected">Выделение</button>
        <button id="lineTool">Линия</button>
        <button id="rectTool">Прямоугольник</button>
        <button id="circleTool">Круг</button>
        <button id="deleteBtn">Удалить</button>
    </div>

    <canvas id="canvas"></canvas>
    <div class="status-bar">
        <span id="cursorPos">X: 0, Y: 0</span>
        <span id="selectedInfo">Выделено: 0</span>
    </div>

<script>
"use strict";
class Editor {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.tools = ['select', 'line', 'rect', 'circle'];
        this.state = {
            elements: [],
            selected: new Set(),
            offset: { x: 0, y: 0 },
            scale: 1,
            currentTool: 'select',
            isDragging: false,
            startPos: { x: 0, y: 0 },
            currentElement: null
        };

        this.init();
    }

    init() {
        this.setupCanvas();
        this.setupEventListeners();
        this.draw();
    }

    setupCanvas() {
        this.canvas.width = window.innerWidth - 40;
        this.canvas.height = window.innerHeight - 100;
    }

    setupEventListeners() {
        this.tools.forEach(tool => {
            document.getElementById(`${tool}Tool`).addEventListener('click', () => {
                this.setTool(tool);
            });
        });

        document.getElementById('deleteBtn').addEventListener('click', () => {
            this.deleteSelected();
        });

        this.canvas.addEventListener('mousedown', e => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', e => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', () => this.handleMouseUp());
        this.canvas.addEventListener('wheel', e => this.handleWheel(e));
        window.addEventListener('resize', () => this.setupCanvas());
    }

    setTool(tool) {
        this.state.currentTool = tool;
        document.querySelectorAll('.toolbar button').forEach(btn => {
            btn.classList.remove('selected');
        });
        document.getElementById(`${tool}Tool`).classList.add('selected');
    }

    getMousePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        return {
            x: (e.clientX - rect.left - this.state.offset.x) / this.state.scale,
            y: (e.clientY - rect.top - this.state.offset.y) / this.state.scale
        };
    }

    handleMouseDown(e) {
        const pos = this.getMousePos(e);
        this.state.isDragging = true;
        this.state.startPos = pos;

        if(this.state.currentTool !== 'select') {
            this.state.currentElement = {
                type: this.state.currentTool,
                x1: pos.x,
                y1: pos.y,
                x2: pos.x,
                y2: pos.y,
                color: '#2196F3'
            };
        } else {
            this.handleSelection(pos);
        }
    }

    updateCurrentElement(pos) {
        if(!this.state.currentElement) return;
        
        this.state.currentElement.x2 = pos.x;
        this.state.currentElement.y2 = pos.y;

        if(this.state.currentElement.type === 'rect') {
            this.state.currentElement.width = pos.x - this.state.currentElement.x1;
            this.state.currentElement.height = pos.y - this.state.currentElement.y1;
        }

        if(this.state.currentElement.type === 'circle') {
            this.state.currentElement.radius = Math.hypot(
                pos.x - this.state.currentElement.x1,
                pos.y - this.state.currentElement.y1
            );
        }

        this.draw();
    }

    handleMouseMove(e) {
        const pos = this.getMousePos(e);
        this.updateCursorPos(pos);

        if(this.state.isDragging) {
            if(this.state.currentTool === 'select') {
                this.state.offset.x += e.movementX;
                this.state.offset.y += e.movementY;
            } else {
                this.updateCurrentElement(pos);
            }
            this.draw();
        }
    }

    handleMouseUp() {
        if(this.state.currentElement) {
            this.state.elements.push(this.state.currentElement);
            this.state.currentElement = null;
        }
        this.state.isDragging = false;
        this.draw();
    }

    handleSelection(pos) {
        this.state.selected.clear();
        this.state.elements.forEach((element, index) => {
            if(element && this.checkCollision(element, pos)) {
                this.state.selected.add(index);
            }
        });
        this.updateSelectedInfo();
        this.draw();
    }

    checkCollision(element, pos) {
        if(!element?.type) return false;
        
        switch(element.type) {
            case 'rect':
                return pos.x >= element.x1 && pos.x <= element.x1 + element.width &&
                       pos.y >= element.y1 && pos.y <= element.y1 + element.height;
            case 'circle':
                return Math.hypot(pos.x - element.x1, pos.y - element.y1) <= element.radius;
            case 'line':
                const dx = element.x2 - element.x1;
                const dy = element.y2 - element.y1;
                const t = ((pos.x - element.x1) * dx + (pos.y - element.y1) * dy) / (dx*dx + dy*dy);
                return t >= 0 && t <= 1;
        }
        return false;
    }

    deleteSelected() {
        this.state.elements = this.state.elements.filter((_, i) => !this.state.selected.has(i));
        this.state.selected.clear();
        this.updateSelectedInfo();
        this.draw();
    }

    updateCursorPos(pos) {
        document.getElementById('cursorPos').textContent = 
            `X: ${Math.round(pos.x)}, Y: ${Math.round(pos.y)}`;
    }

    updateSelectedInfo() {
        document.getElementById('selectedInfo').textContent = 
            `Выделено: ${this.state.selected.size}`;
    }

    draw() {
        this.ctx.save();
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.translate(this.state.offset.x, this.state.offset.y);
        this.ctx.scale(this.state.scale, this.state.scale);

        // Отрисовка элементов
        this.state.elements.forEach((element, index) => {
            if(!element?.type) return;
            
            this.ctx.beginPath();
            this.ctx.strokeStyle = this.state.selected.has(index) ? '#f44336' : '#2196F3';
            this.ctx.lineWidth = 2;

            switch(element.type) {
                case 'line':
                    this.ctx.moveTo(element.x1, element.y1);
                    this.ctx.lineTo(element.x2, element.y2);
                    break;
                case 'rect':
                    this.ctx.rect(element.x1, element.y1, element.width, element.height);
                    break;
                case 'circle':
                    this.ctx.arc(element.x1, element.y1, element.radius, 0, Math.PI*2);
                    break;
            }
            this.ctx.stroke();
        });

        // Отрисовка текущего элемента
        if(this.state.currentElement) {
            this.ctx.beginPath();
            this.ctx.strokeStyle = '#2196F3';
            this.ctx.lineWidth = 2;
            
            switch(this.state.currentElement.type) {
                case 'line':
                    this.ctx.moveTo(this.state.currentElement.x1, this.state.currentElement.y1);
                    this.ctx.lineTo(this.state.currentElement.x2, this.state.currentElement.y2);
                    break;
                case 'rect':
                    this.ctx.rect(
                        this.state.currentElement.x1,
                        this.state.currentElement.y1,
                        this.state.currentElement.width,
                        this.state.currentElement.height
                    );
                    break;
                case 'circle':
                    this.ctx.arc(
                        this.state.currentElement.x1,
                        this.state.currentElement.y1,
                        this.state.currentElement.radius,
                        0,
                        Math.PI*2
                    );
                    break;
            }
            this.ctx.stroke();
        }

        this.ctx.restore();
    }

    handleWheel(e) {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        this.state.scale *= delta;
        this.draw();
    }
}

window.addEventListener('DOMContentLoaded', () => {
    const editor = new Editor();
});
</script>
</body>
</html>
